package main

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"strconv"
	"time"

	"go.uber.org/zap"
)

/*
Production - https://api.delta.exchange
Testnet - https://testnet-api.delta.exchange
*/
//const apiBaseURL string = "https://api.delta.exchange"

const apiBaseURL string = "https://api.delta.exchange"
const apiKey string = "f94349291a476342ff343352e86b14"
const apiSecret string = "578c211026cb3b2733ed1f6e844ea91f6c4ade9a297c324642a705678d25"

var logger = createLogger()

func createLogger() *zap.Logger {
	logger, err := zap.NewProduction()
	if err != nil {
		log.Fatalf("can't initialize zap logger: %v", err)
	}
	return logger
}

/*
use log.panic https://quasilyte.dev/blog/post/log-fatal-vs-log-panic/
*/
func getJSONPublic(url string) string {
	log.Printf("Trying to call url : %s\n", url)
	var responseString string = ""
	resp, err := http.Get(url)
	if err != nil {
		log.Panic(err)
	} else {
		if resp.StatusCode >= 200 && resp.StatusCode <= 299 {
			log.Println("HTTP Status is in the 2xx range")
		}
		body, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			log.Panic(err)
		} else {
			responseString := string(body)
			log.Println(responseString)
		}
	}
	return responseString
}

func getJSONPrivate(requestPath string, queryParameter string) string {
	logger.Warn("hahaha")
	timeStamp := getCurrentTimeStamp()
	signature := getAPISignature("GET", requestPath, queryParameter, "", timeStamp)
	url := fmt.Sprintf("%s%s%s", apiBaseURL, requestPath, queryParameter)

	fmt.Printf("The URL to send the request is : %s\n", url)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		log.Fatal("Error reading request. ", err)
	}

	req.Header.Set("api-key", apiKey)
	req.Header.Set("timestamp", timeStamp)
	req.Header.Set("signature", signature)
	//fmt.Printf("Signature is : %s", signature)
	req.Header.Set("User-Agent", "rest-client")
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{Timeout: time.Second * 10}

	resp, err := client.Do(req)
	if err != nil {
		log.Fatal("Error reading response. \n", err)
	}

	//defer
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal("Error reading body. \n", err)
	} else {
		responseString := string(body)
		fmt.Println(responseString)
		log.Print("Get the response. \n")
	}

	resp.Body.Close()

	fmt.Printf("Response %s\n", body)

	return fmt.Sprintf("Response %s\n", body)
}

func getCurrentTimeStamp() string {
	now := time.Now()
	secs := now.Unix()
	return strconv.FormatInt(secs, 10)
}

func generateSignature(data string, secret string) string {
	fmt.Printf("Secret: %s Data: %s\n", secret, data)

	// Create a new HMAC by defining the hash type and the key (as byte array)
	h := hmac.New(sha256.New, []byte(secret))

	// Write Data to it
	h.Write([]byte(data))

	// Get result and encode as hexadecimal string
	sha := hex.EncodeToString(h.Sum(nil))

	return sha
}

func getAPISignature(method string, requestPath string, queryParameter string, body string, timeStamp string) string {

	/*
	   The signature header is generated by creating a sha256 HMAC using the secret key on the prehash
	   string method + timestamp + requestPath + query params + body (where + represents string concatenation) and convert output to hexdigest.
	   The timestamp value is the same as the 'timestamp' header.
	*/
	return generateSignature(method+timeStamp+requestPath+queryParameter+body, apiSecret)
}

func main() {

	//assetURL := fmt.Sprintf("%s/assets", apiBaseURL)
	//productsURL := fmt.Sprintf("%s/products", apiBaseURL)

	getJSONPrivate("/orders", "?product_id=1&state=open")

	//	getJSONPublic(assetURL)
	//	getJSONPublic(productsURL)

	url := "test"
	logger, _ := zap.NewProduction()
	defer logger.Sync() // flushes buffer, if any
	sugar := logger.Sugar()
	sugar.Infow("failed to fetch URL",
		// Structured context as loosely typed key-value pairs.
		"url", url,
		"attempt", 3,
		"backoff", time.Second,
	)
	sugar.Infof("Failed to fetch URL: %s", url)

}
